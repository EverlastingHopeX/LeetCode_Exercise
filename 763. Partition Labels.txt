class Solution {
    public List<Integer> partitionLabels(String S) {
        int[][] vocRange=new int[26][2];
        char[] chArr=S.toCharArray();
        for(int i=0;i<chArr.length;i++){
            int idx=chArr[i]-'a';
            if(vocRange[idx][0]==-1){
                vocRange[idx][0]=i;
            }
            vocRange[idx][1]=i;
        }
        int i=0;
        List<Integer> ans=new ArrayList<>();
        while(i<chArr.length){
            int t=i;
            i=expand(chArr,i,vocRange);
            ans.add(i-t+1);
            i++;
        }
        
        return ans;
    }
    
    private int expand(char[] chArr, int idx, int[][] vocRange){
        // System.out.println("expand "+idx);
        int start=idx, end=vocRange[chArr[idx]-'a'][1];
        while(start<end){
            // System.out.println(start+" "+end);
            int nEnd=end;
            for(int i=start;i<end;i++){
                nEnd=Math.max(nEnd,vocRange[chArr[i]-'a'][1]);
            }
            start=end+1;
            if(nEnd!=end){
                end=nEnd;
            }
        }
        return end;
    }
}

Runtime: 1 ms, faster than 100.00% of Java online submissions for Partition Labels.
Memory Usage: 38 MB, less than 76.60% of Java online submissions for Partition Labels.

The algorithm is simple, only expand when it is necessary.

class Solution {
    public List<Integer> partitionLabels(String S) {
        Map<Character, int[]> range=new HashMap<>();
        for(int i=0;i<S.length();i++){
            char ch=S.charAt(i);
            int[] r=range.getOrDefault(ch,new int[]{i,-1});
            r[1]=i;
            range.put(ch,r);
        }
        boolean[] used=new boolean[26];
        List<Integer> ans=new ArrayList<>();
        int p=0;
        while(p<S.length()){
            int idx=S.charAt(p)-'a';
            if(used[idx]){
                continue;
            }
            
            int left=p,right=p;
            while(p<=right){
                idx=S.charAt(p)-'a';
                if(!used[idx]){
                    used[idx]=true;
                    int[] r=range.get(S.charAt(p));
                    right=Math.max(right,r[1]);
                }
                p++;
            }
            // System.out.println(left+" "+right);
            ans.add(right-left+1);
        }
        return ans;
    }
}

Worse solution compared with my previous one.
There is no need to use hashmap when there are definitive number of entries.