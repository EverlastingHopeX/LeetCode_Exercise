Using Sort

class Solution {
    public int lastStoneWeight(int[] stones) {
        int pos=stones.length-1;
        if(pos==0){
            return stones[0];
        }
        int fir=0;
        int sec=0;
        Arrays.sort(stones);
        while(stones[pos-1]!=0){
            // for(int i=0;i<=pos;i++){
            //     System.out.println(stones[i]);
            // }
            stones[pos]-=stones[pos-1];
            stones[pos-1]=0;
            Arrays.sort(stones);
        }
        return stones[pos];
    }
}

Runtime: 1 ms, faster than 97.51% of Java online submissions for Last Stone Weight.
Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.

Using PriorityQueue

class Solution {
     public int lastStoneWeight(int[] stones) {
        PriorityQueue<Integer> q = new PriorityQueue<>(Comparator.reverseOrder());
        for (int st : stones){
            q.offer(st); 
        }
        while (q.size() > 1) {
            q.offer(q.poll() - q.poll());
        }
        return q.peek();
    }
}

Runtime: 1 ms, faster than 97.51% of Java online submissions for Last Stone Weight.
Memory Usage: 34 MB, less than 100.00% of Java online submissions for Last Stone Weight.

The performance seems to be the same, however, priority queue may achieve better performance when complex problems involved