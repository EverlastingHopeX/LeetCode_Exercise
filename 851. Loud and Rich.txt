Didn't work it out.
My solution is not accepted as memory limit exceeded.

class Solution {
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        int num=quiet.length;
        List[] richerList=new ArrayList[num];
        //initialize
        for(int i=0;i<num;i++){
            richerList[i]=new ArrayList<Integer>();
        }
        for(int i=0;i<richer.length;i++){
            int rich=richer[i][0];
            int poor=richer[i][1];
            richerList[poor].add(rich);
            // System.out.println(rich+" is richer than "+poor);
        }
        boolean[] visited=new boolean[num];
        for(int i=0;i<num;i++){
            DFS(richerList, i, visited);
        }
        int[] ans=new int[num];
        for(int i=0;i<num;i++){
            // System.out.println("i: "+i);
            ans[i]=i;
            int min=quiet[i];
            ListIterator<Integer> it=richerList[i].listIterator();
            while(it.hasNext()){
                int p=it.next();
                // System.out.println("richer "+p+" quiet: "+quiet[p]);
                if(quiet[p]<min){
                    min=quiet[p];
                    ans[i]=p;
                }
            }
        }
        return ans;
    }
    
    private void DFS(List[] richerList, int idx, boolean[] visited){
        // System.out.println("update list for "+idx);
        if(visited[idx]){
            // System.out.println("visited");
            return;
        }
        ListIterator<Integer> idxIt=richerList[idx].listIterator();
        while(idxIt.hasNext()){
            int r=idxIt.next();
            // System.out.println("r:"+r+" of "+idx);
            //go deeper and update if not visited
            if(!visited[r]){
                DFS(richerList, r, visited);
            }
            ListIterator<Integer> it=richerList[r].listIterator();
            while(it.hasNext()){
                int t=it.next();
                idxIt.add(t);
            }
        }
        visited[idx]=true;
    }
}

The solution below is other's accepted solution based on DFS.
https://leetcode.com/problems/loud-and-rich/discuss/137918/C%2B%2BJavaPython-Concise-DFS